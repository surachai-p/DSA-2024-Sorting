def selection_sort(arr):
    n = len(arr)
    
    # วนลูปเพื่อหาค่ามากที่สุดในแต่ละรอบ
    for i in range(n):
        # สมมติว่าตำแหน่งปัจจุบันมีค่ามากที่สุด
        max_idx = i
        
        # หาค่าที่มากกว่าในส่วนที่เหลือ
        for j in range(i+1, n):
            if arr[j] > arr[max_idx]:  # เปลี่ยนเงื่อนไขเป็นหาค่ามากที่สุด
                max_idx = j
        
        # สลับค่าที่มากที่สุดกับตำแหน่งปัจจุบัน
        arr[i], arr[max_idx] = arr[max_idx], arr[i]
    
    return arr

import time
# ทดสอบ Selection Sort
test_data = [64, 34, 25, 12, 22, 11, 45, 24, 6, 90]
print("ข้อมูลก่อนเรียง:", test_data)

start_time = time.time()
sorted_data = selection_sort(test_data.copy())
end_time = time.time()

print("ข้อมูลหลังเรียง:", sorted_data)
print(f"เวลาที่ใช้: {(end_time - start_time)*1000:.6f} มิลลิวินาที")

def selection_sort_with_steps(arr):
    n = len(arr)
    
    for i in range(n):
        max_idx = i
        print(f"\nรอบที่ {i+1}:")
        print(f"  ข้อมูลปัจจุบัน: {arr}")
        print(f"  ค้นหาค่ามากที่สุดในตำแหน่ง {i} ถึง {n-1}")
        
        for j in range(i+1, n):
            print(f"    เปรียบเทียบ {arr[max_idx]} กับ {arr[j]}", end=" -> ")
            if arr[j] > arr[max_idx]:  # เปลี่ยนเงื่อนไขเป็นหาค่ามากที่สุด
                max_idx = j
                print(f"พบค่าที่มากกว่า: {arr[j]}")
            else:
                print("ไม่มีการเปลี่ยนแปลง")
        
        print(f"  ค่ามากที่สุดคือ {arr[max_idx]} ที่ตำแหน่ง {max_idx}")
        if i != max_idx:
            print(f"  สลับ {arr[i]} กับ {arr[max_idx]}")
            arr[i], arr[max_idx] = arr[max_idx], arr[i]
        else:
            print(f"  ไม่ต้องสลับเนื่องจากอยู่ในตำแหน่งที่ถูกต้องแล้ว")
        
        print(f"  ข้อมูลหลังรอบที่ {i+1}: {arr}")
    
    return arr

# ทดสอบแสดงขั้นตอน
test_data = [64, 45, 25, 12, 22, 11, 34, 24, 6, 90]
selection_sort_with_steps(test_data.copy())
